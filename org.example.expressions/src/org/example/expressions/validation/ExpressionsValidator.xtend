/*
 * generated by Xtext
 */
package org.example.expressions.validation

import com.google.inject.Inject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check
import org.example.expressions.expressions.Comparison
import org.example.expressions.expressions.Equality
import org.example.expressions.expressions.Expression
import org.example.expressions.expressions.ExpressionsPackage
import org.example.expressions.expressions.Type
import org.example.expressions.expressions.VariableRef
import org.example.expressions.typing.ExpressionsTypeConformanceComputer
import org.example.expressions.typing.ExpressionsTypeProvider
import org.example.expressions.typing.ExpressionsTypeUtils

import static extension org.example.expressions.typing.ExpressionsModelUtil.*

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ExpressionsValidator extends AbstractExpressionsValidator {

	public static val FORWARD_REFERENCE = "org.example.expressions.ForwardReference";

	public static val WRONG_TYPE = "org.example.expressions.WrongType";

	@Inject extension ExpressionsTypeProvider
	@Inject extension ExpressionsTypeUtils
	@Inject extension ExpressionsTypeConformanceComputer
	
	static val packageInstance = ExpressionsPackage.eINSTANCE

	@Check
	def void checkForwardReference(VariableRef varRef) {
		val variable = varRef.getVariable()
		if (variable != null && !varRef.variablesDefinedBefore.contains(
				variable)) {
			error("variable forward reference not allowed: '"
					+ variable.name + "'",
					packageInstance.variableRef_Variable,
					FORWARD_REFERENCE, variable.name)
		}
	}

	@Check
	def void checkTypeConformance(Expression exp) {
		val actualType = exp.inferredType
		val expectedType = exp.expectedType
		
		if (expectedType !== null &&
				!actualType.isAssignableTo(expectedType)) {
			error("expected " +
					expectedType.representation + ", but was " +
					actualType.representation,
					exp.eContainer,
					exp.eContainingFeature,
					WRONG_TYPE)
		}
	}

	@Check
	def checkType(Equality equality) {
		val leftType = equality.left.inferredType
		val rightType = equality.right?.inferredType
		checkExpectedSame(leftType, rightType)
	}

	@Check
	def checkType(Comparison comparison) {
		val leftType = comparison.left.inferredType
		val rightType = comparison.right?.inferredType
		checkExpectedSame(leftType, rightType)
		checkNotBoolean(leftType, packageInstance.comparison_Left)
		checkNotBoolean(rightType, packageInstance.comparison_Right)
	}

	def private checkExpectedSame(Type left, Type right) {
		if (right != null && left != null && right.eClass != left.eClass) {
			error("expected the same type, but was " + left.representation + ", " + right.representation,
					ExpressionsPackage.Literals.EQUALITY.getEIDAttribute(),
					WRONG_TYPE)
		}
	}

	def private checkNotBoolean(Type type, EReference reference) {
		if (type.isBoolean) {
			error("cannot be boolean", reference, WRONG_TYPE)
		}
	}

}
